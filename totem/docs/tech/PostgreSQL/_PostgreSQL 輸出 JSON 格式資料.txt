
# PostgreSQL 輸出 JSON 格式資料
* PostgresQL 9.2 開始引入Json格式欄位, 這次會用到 9.4 版 開始提供的 json_build_object(), json_agg() 函式
* [reference](https://www.postgresql.org/docs/9.4/static/functions-json.html)

## 情境
table A

|  barcode  |  qnumber  |  q_text  |  answer_text  |
|  B123456  |  B-1-1-1  |  textQ1  |  ansText0001  |
|  C123456  |  C-1-1-1  |  textQ2  |  ansText0002  |

## 接著將 q_text, answer_text 欄位轉成 Json 物件並合併, 以 barcode 做 group by 
<code>
--長庚檢驗
select substring(barcode, 1, 6 ) as sds_id, barcode, json_agg(json_build_object('key', COALESCE(q_text, ''), 'value', COALESCE(answer_text, '') ) ) as data
from
(
select ab.barcode, q.qnumber, 
q.text as q_text, ans.rawanswertext as answer_text
from QuestionResponse qr
left join question q on q.id = qr.question_id
left join questionoption qo on q.id = qo.question_id
left join answer ans on qr.id = ans.question_response_id and ans.question_option_id = qo.id
left join answerbook ab on ab.id = qr.answer_book_id
left join crf crf on ab.crf_id=crf.id
where crf.name like '%長庚檢驗%'
--and ab.barcode like 'AAA065%'
and qo.answertype!='MISSING_VALUE'
and ( q.qnumber like '%-1' or q.qnumber like '%-3' )
and q.qnumber not like 'A%'
order by ab.barcode,
substring(q.qnumber, 1, 1),
case when q.qnumber like '%-%' then regexp_split_to_array( substring(q.qnumber, 3), '-')::int[] else array[0] end
) agg
GROUP BY barcode
</code>


## 撈出的欄位會是這樣

|  SDS_ID   |  barcode  |  data  |
|  SDS3333  |  B123456  |  {{"key" : "WBC", "value" : "5.5"}{"key" : "RBC", "value" : "6.6"}}  |
|  SDS3444  |  C123456  |  {{"key" : "WBC", "value" : "5.9"}{"key" : "RBC", "value" : "6.9"}}  |


## 接著 java 端以 Google Gson 解譯
<code>
 private class JsonObj{
        private String key;
         
        private String value;
         
        public String getKey() {
            return key;
        }
        public void setKey(String key) {
            this.key = key;
        }
        public String getValue() {
            return value;
        }
        public void setValue(String value) {
            this.value = value;
        }
    }      
  
    /* parse by Gson */
        Type type = new TypeToken<JsonObj[]>() {}.getType();
        JsonObj[] jsonList = new Gson().fromJson(strArray[2], type);
        for (JsonObj obj : jsonList) {
            System.err.println(obj.getKey());
            System.err.println(obj.getValue());
        }
</code>


## 註: PostgreSQL 9.2版可以用以下的方式輸出 (8.4版不支援)
<code>
CREATE OR REPLACE VIEW cgmh_labdata AS
--長庚檢驗
select substring(barcode, 1, 6 ) as sds_id, barcode,
CONCAT('[',
  string_agg(
    '{' || '"key" : ' || CONCAT('"', COALESCE(q_text, ''), '"') || ', ' || '"value" : ' || CONCAT('"', COALESCE(answer_text, ''), '"') || '}'
  , ',')
, ']') as data
from
(
select ab.barcode, q.qnumber, 
q.text as q_text, ans.rawanswertext as answer_text
from QuestionResponse qr
left join question q on q.id = qr.question_id
left join questionoption qo on q.id = qo.question_id
left join answer ans on qr.id = ans.question_response_id and ans.question_option_id = qo.id
left join answerbook ab on ab.id = qr.answer_book_id
left join crf crf on ab.crf_id=crf.id
where crf.name like '%長庚檢驗%'
--and ab.barcode like 'AAA065%'
and ab.barcode is not null
and qo.answertype!='MISSING_VALUE'
and ( q.qnumber like '%-1' or q.qnumber like '%-3' )
and q.qnumber not like 'A%'
order by ab.barcode,
substring(q.qnumber, 1, 1),
case when q.qnumber like '%-%' then regexp_split_to_array( substring(q.qnumber, 3), '-')::int[] else array[0] end
) agg
GROUP BY barcode;
</code>

