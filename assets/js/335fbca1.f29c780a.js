"use strict";(globalThis.webpackChunkinsect_totem=globalThis.webpackChunkinsect_totem||[]).push([[919],{28453:(r,e,n)=>{n.d(e,{R:()=>s,x:()=>p});var t=n(96540);const a={},i=t.createContext(a);function s(r){const e=t.useContext(i);return t.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function p(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(a):r.components||a:s(r.components),t.createElement(i.Provider,{value:e},r.children)}},78284:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>p,default:()=>d,frontMatter:()=>s,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"Java/Java_Zip_with_Pwd","title":"Java \u89e3\u58d3\u7e2e\u4e26\u52a0\u5bc6","description":"Reading pwd protected zip file","source":"@site/docs/110_Java/Java_Zip_with_Pwd.md","sourceDirName":"110_Java","slug":"/Java/Java_Zip_with_Pwd","permalink":"/docs/Java/Java_Zip_with_Pwd","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Java \u89e3\u58d3\u7e2e\u4e26\u52a0\u5bc6","description":"Reading pwd protected zip file","keywords":["Java","zip","pasword"]},"sidebar":"totem_sidebar","previous":{"title":"Java \u58d3\u7e2e\u6a94\u5167\u7684\u4e2d\u6587\u6a94\u6848\u540d\u4e82\u78bc","permalink":"/docs/Java/Java_Zip_Chinese"},"next":{"title":"Java \u6f22\u5b57\u8fa8\u5225","permalink":"/docs/Java/Java_is_Han_String"}}');var a=n(74848),i=n(28453);const s={title:"Java \u89e3\u58d3\u7e2e\u4e26\u52a0\u5bc6",description:"Reading pwd protected zip file",keywords:["Java","zip","pasword"]},p=void 0,l={},o=[{value:"Java \u89e3\u58d3\u7e2e\u52a0\u5bc6\u7684 zip \u6a94",id:"java-\u89e3\u58d3\u7e2e\u52a0\u5bc6\u7684-zip-\u6a94",level:2},{value:"\u5176\u4ed6",id:"\u5176\u4ed6",level:2}];function c(r){const e={a:"a",br:"br",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...r.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h2,{id:"java-\u89e3\u58d3\u7e2e\u52a0\u5bc6\u7684-zip-\u6a94",children:"Java \u89e3\u58d3\u7e2e\u52a0\u5bc6\u7684 zip \u6a94"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"\u7db2\u8def\u4e0a\u627e\u5230\u4ee5 Java \u89e3\u58d3\u7e2e\u52a0\u5bc6(\u9700\u8981\u5bc6\u78bc)\u7684 zip \u6a94\u7684\u65b9\u6cd5\uff0c\u7559\u8457\u505a\u53c3\u8003"}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:["\u539f\u59cb\u51fa\u8655 ",(0,a.jsx)(e.a,{href:"http://blog.alutam.com/2009/10/31/reading-password-protected-zip-files-in-java/",children:"reading-password-protected-zip-files-in-java"})]}),"\n",(0,a.jsxs)(e.p,{children:["\u4f5c\u8005\u5beb\u4e86\u4e00\u500b\u985e\u5225 ZipDecryptInputStream \u8655\u7406\u89e3\u5bc6 zip \u7684\u5de5\u4f5c",(0,a.jsx)(e.br,{}),"\n","\u7a0b\u5f0f\u6700\u5f8c\u9762\u7684 main() \u662f\u4f7f\u7528\u7bc4\u4f8b",(0,a.jsx)(e.br,{}),"\n","\u5176\u4e2d\u52a0\u5bc6\u7684 zip \u6a94\u4ee5 7-Zip \u88fd\u4f5c"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'     \r\n    import java.io.FileInputStream;\r\n    import java.io.FileOutputStream;\r\n    import java.io.IOException;\r\n    import java.io.InputStream;\r\n    import java.util.zip.ZipEntry;\r\n    import java.util.zip.ZipInputStream;\r\n     \r\n    public class ZipDecryptInputStream extends InputStream {\r\n        private static final int[] CRC_TABLE = new int[256];\r\n        // compute the table\r\n        // (could also have it pre-computed - see\r\n        // http://snippets.dzone.com/tag/crc32)\r\n        static {\r\n            for (int i = 0; i < 256; i++) {\r\n                int r = i;\r\n                for (int j = 0; j < 8; j++) {\r\n                    if ((r & 1) == 1) {\r\n                        r = (r >>> 1) ^ 0xedb88320;\r\n                    } else {\r\n                        r >>>= 1;\r\n                    }\r\n                }\r\n                CRC_TABLE[i] = r;\r\n            }\r\n        }\r\n     \r\n        private static final int DECRYPT_HEADER_SIZE = 12;\r\n     \r\n        private static final int[] LFH_SIGNATURE = { 0x50, 0x4b, 0x03, 0x04 };\r\n     \r\n        private final InputStream delegate;\r\n     \r\n        private final String password;\r\n     \r\n        private final int keys[] = new int[3];\r\n     \r\n        private State state = State.SIGNATURE;\r\n     \r\n        private int skipBytes;\r\n     \r\n        private int compressedSize;\r\n     \r\n        private int value;\r\n     \r\n        private int valuePos;\r\n     \r\n        private int valueInc;\r\n     \r\n        public ZipDecryptInputStream(InputStream stream, String password) {\r\n            this.delegate = stream;\r\n            this.password = password;\r\n        }\r\n     \r\n        @Override\r\n        public int read() throws IOException {\r\n            int result = delegate.read();\r\n            if (skipBytes == 0) {\r\n                switch (state) {\r\n                case SIGNATURE:\r\n                    if (result != LFH_SIGNATURE[valuePos]) {\r\n                        state = State.TAIL;\r\n                    } else {\r\n                        valuePos++;\r\n                        if (valuePos >= LFH_SIGNATURE.length) {\r\n                            skipBytes = 2;\r\n                            state = State.FLAGS;\r\n                        }\r\n                    }\r\n                    break;\r\n                case FLAGS:\r\n                    if ((result & 1) == 0) {\r\n                        throw new IllegalStateException(\r\n                                "ZIP not password protected.");\r\n                    }\r\n                    if ((result & 64) == 64) {\r\n                        throw new IllegalStateException("Strong encryption used.");\r\n                    }\r\n                    if ((result & 8) == 8) {\r\n                        throw new IllegalStateException("Unsupported ZIP format.");\r\n                    }\r\n                    result -= 1;\r\n                    compressedSize = 0;\r\n                    valuePos = 0;\r\n                    valueInc = DECRYPT_HEADER_SIZE;\r\n                    state = State.COMPRESSED_SIZE;\r\n                    skipBytes = 11;\r\n                    break;\r\n                case COMPRESSED_SIZE:\r\n                    compressedSize += result << (8 * valuePos);\r\n                    result -= valueInc;\r\n                    if (result < 0) {\r\n                        valueInc = 1;\r\n                        result += 256;\r\n                    } else {\r\n                        valueInc = 0;\r\n                    }\r\n                    valuePos++;\r\n                    if (valuePos > 3) {\r\n                        valuePos = 0;\r\n                        value = 0;\r\n                        state = State.FN_LENGTH;\r\n                        skipBytes = 4;\r\n                    }\r\n                    break;\r\n                case FN_LENGTH:\r\n                case EF_LENGTH:\r\n                    value += result << 8 * valuePos;\r\n                    if (valuePos == 1) {\r\n                        valuePos = 0;\r\n                        if (state == State.FN_LENGTH) {\r\n                            state = State.EF_LENGTH;\r\n                        } else {\r\n                            state = State.HEADER;\r\n                            skipBytes = value;\r\n                        }\r\n                    } else {\r\n                        valuePos = 1;\r\n                    }\r\n                    break;\r\n                case HEADER:\r\n                    initKeys(password);\r\n                    for (int i = 0; i < DECRYPT_HEADER_SIZE; i++) {\r\n                        updateKeys((byte) (result ^ decryptByte()));\r\n                        result = delegate.read();\r\n                    }\r\n                    compressedSize -= DECRYPT_HEADER_SIZE;\r\n                    state = State.DATA;\r\n                    // intentionally no break\r\n                case DATA:\r\n                    result = (result ^ decryptByte()) & 0xff;\r\n                    updateKeys((byte) result);\r\n                    compressedSize--;\r\n                    if (compressedSize == 0) {\r\n                        valuePos = 0;\r\n                        state = State.SIGNATURE;\r\n                    }\r\n                    break;\r\n                case TAIL:\r\n                    // do nothing\r\n                }\r\n            } else {\r\n                skipBytes--;\r\n            }\r\n            return result;\r\n        }\r\n     \r\n        @Override\r\n        public void close() throws IOException {\r\n            delegate.close();\r\n            super.close();\r\n        }\r\n     \r\n        private void initKeys(String password) {\r\n            keys[0] = 305419896;\r\n            keys[1] = 591751049;\r\n            keys[2] = 878082192;\r\n            for (int i = 0; i < password.length(); i++) {\r\n                updateKeys((byte) (password.charAt(i) & 0xff));\r\n            }\r\n        }\r\n     \r\n        private void updateKeys(byte charAt) {\r\n            keys[0] = crc32(keys[0], charAt);\r\n            keys[1] += keys[0] & 0xff;\r\n            keys[1] = keys[1] * 134775813 + 1;\r\n            keys[2] = crc32(keys[2], (byte) (keys[1] >> 24));\r\n        }\r\n     \r\n        private byte decryptByte() {\r\n            int temp = keys[2] | 2;\r\n            return (byte) ((temp * (temp ^ 1)) >>> 8);\r\n        }\r\n     \r\n        private int crc32(int oldCrc, byte charAt) {\r\n            return ((oldCrc >>> 8) ^ CRC_TABLE[(oldCrc ^ charAt) & 0xff]);\r\n        }\r\n     \r\n        private static enum State {\r\n            SIGNATURE, FLAGS, COMPRESSED_SIZE, FN_LENGTH, EF_LENGTH, HEADER, DATA, TAIL\r\n        }\r\n     \r\n        public static void main(String[] args) throws Exception {\r\n            FileInputStream fis = new FileInputStream("d:/test.zip");\r\n            // wrap it in the decrypt stream\r\n            ZipDecryptInputStream zdis = new ZipDecryptInputStream(fis, "1111");\r\n            // wrap the decrypt stream by the ZIP input stream\r\n            ZipInputStream zis = new ZipInputStream(zdis);\r\n     \r\n            // read all the zip entries and save them as files\r\n            ZipEntry ze;\r\n     \r\n            while ((ze = zis.getNextEntry()) != null) {\r\n                FileOutputStream fos = new FileOutputStream("d:/result/" + ze.getName());\r\n     \r\n                int len;\r\n                byte[] buf = new byte[256];\r\n     \r\n                while ((len = zis.read(buf)) != -1) {\r\n                    fos.write(buf, 0, len);\r\n                }\r\n     \r\n                fos.close();\r\n                zis.closeEntry();\r\n            }\r\n            zis.close();\r\n     \r\n            System.out.println("done.");\r\n        }\r\n    }\n'})}),"\n",(0,a.jsx)(e.h2,{id:"\u5176\u4ed6",children:"\u5176\u4ed6"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"./Java_Zip_Chinese",children:"Java \u58d3\u7e2e\u6a94\u5167\u7684\u4e2d\u6587\u6a94\u6848\u540d\u4e82\u78bc"})}),"\n"]})]})}function d(r={}){const{wrapper:e}={...(0,i.R)(),...r.components};return e?(0,a.jsx)(e,{...r,children:(0,a.jsx)(c,{...r})}):c(r)}}}]);